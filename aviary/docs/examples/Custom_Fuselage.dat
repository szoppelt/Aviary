0.0 0.5
0.5 0.45
1.0 0.4
1.5 0.6
2.0 0.3
2.5 0.35

class CenterOfGravity3D(om.ExplicitComponent):
    def initialize(self):
        self.options.declare('num_sections', types=int, default=50)
        self.options.declare('airfoil_type', types=str, default='2412')  
        self.options.declare('material', default='metal', values=['wood', 'metal', 'carbon_fiber'])
        self.options.declare('airfoil_data_file', default=None, types=str)  

    def setup(self):
        num_sections = self.options['num_sections']

        # Inputs
        self.add_input('span', val=10.0, units='m')  
        self.add_input('root_chord', val=2.0, units='m')  
        self.add_input('tip_chord', val=1.0, units='m')  
        self.add_input('twist', val=np.zeros(num_sections), units='deg')  
        self.add_input('thickness', val=0.2, units='m')  

        # Outputs
        self.add_output('center_of_gravity_x', val=0.0, units='m')
        self.add_output('center_of_gravity_y', val=0.0, units='m')
        self.add_output('center_of_gravity_z', val=0.0, units='m')
        self.add_output('total_weight', val=0.0, units='kg')
        self.add_output('x_coords', val=np.zeros(num_sections), units='m')
        self.add_output('y_coords', val=np.zeros(num_sections), units='m')
        self.add_output('z_coords', val=np.zeros(num_sections), units='m')

    def setup_partials(self):
        num_sections = self.options['num_sections']

        self.declare_partials(of=['center_of_gravity_x', 'center_of_gravity_y', 'center_of_gravity_z'], 
                              wrt=['span', 'root_chord', 'tip_chord', 'thickness'])
        self.declare_partials(of='total_weight', wrt=['span', 'root_chord', 'tip_chord', 'thickness'])
        self.declare_partials(of='x_coords', wrt=['twist'], rows=np.arange(num_sections), cols=np.arange(num_sections))
        self.declare_partials(of='y_coords', wrt=['span'], rows=np.arange(num_sections), cols=np.arange(num_sections))
        self.declare_partials(of='z_coords', wrt=['twist'], rows=np.arange(num_sections), cols=np.arange(num_sections))

    def compute_partials(self, inputs, partials):
        """Compute the analytical derivatives of outputs with respect to inputs."""
        span = inputs['span']
        root_chord = inputs['root_chord']
        tip_chord = inputs['tip_chord']
        thickness = inputs['thickness']
        num_sections = self.options['num_sections']

        # Compute section locations along the span
        span_locations = np.linspace(0, span, num_sections)
        chord_lengths = root_chord - (root_chord - tip_chord) * (span_locations / span)
        dchord_dspan = (tip_chord - root_chord) / span  # Chord gradient w.r.t. span

        # Compute derivatives of total weight
        total_weight = np.sum(chord_lengths * thickness * (span / num_sections))
        d_weight_dspan = np.sum(dchord_dspan * thickness * (span / num_sections)) + np.sum(chord_lengths * thickness / num_sections)
        d_weight_droot_chord = np.sum(thickness * (span / num_sections))
        d_weight_dtip_chord = np.sum(thickness * (span / num_sections) * (span_locations / span))
        d_weight_dthickness = np.sum(chord_lengths * (span / num_sections))

        partials['total_weight', 'span'] = d_weight_dspan
        partials['total_weight', 'root_chord'] = d_weight_droot_chord
        partials['total_weight', 'tip_chord'] = d_weight_dtip_chord
        partials['total_weight', 'thickness'] = d_weight_dthickness

        # Compute derivatives of center of gravity coordinates
        centroid_xs = chord_lengths / 4  # Approximate centroid of airfoil section
        centroid_ys = span_locations
        centroid_zs = np.zeros_like(span_locations)  # Assuming zero camber

        total_moment_x = np.sum(centroid_xs * chord_lengths * thickness * (span / num_sections))
        total_moment_y = np.sum(centroid_ys * chord_lengths * thickness * (span / num_sections))
        total_moment_z = np.sum(centroid_zs * chord_lengths * thickness * (span / num_sections))

        partials['center_of_gravity_x', 'span'] = (np.sum(dchord_dspan * centroid_xs * thickness * (span / num_sections)) - 
                                                   total_moment_x / total_weight * d_weight_dspan) / total_weight
        partials['center_of_gravity_x', 'root_chord'] = (np.sum(centroid_xs * thickness * (span / num_sections)) - 
                                                         total_moment_x / total_weight * d_weight_droot_chord) / total_weight
        partials['center_of_gravity_x', 'tip_chord'] = (np.sum(centroid_xs * thickness * (span / num_sections) * (span_locations / span)) - 
                                                        total_moment_x / total_weight * d_weight_dtip_chord) / total_weight
        partials['center_of_gravity_x', 'thickness'] = (np.sum(centroid_xs * chord_lengths * (span / num_sections)) - 
                                                        total_moment_x / total_weight * d_weight_dthickness) / total_weight

        partials['center_of_gravity_y', 'span'] = (np.sum(dchord_dspan * centroid_ys * thickness * (span / num_sections)) - 
                                                   total_moment_y / total_weight * d_weight_dspan) / total_weight
        partials['center_of_gravity_y', 'root_chord'] = (np.sum(centroid_ys * thickness * (span / num_sections)) - 
                                                         total_moment_y / total_weight * d_weight_droot_chord) / total_weight
        partials['center_of_gravity_y', 'tip_chord'] = (np.sum(centroid_ys * thickness * (span / num_sections) * (span_locations / span)) - 
                                                        total_moment_y / total_weight * d_weight_dtip_chord) / total_weight
        partials['center_of_gravity_y', 'thickness'] = (np.sum(centroid_ys * chord_lengths * (span / num_sections)) - 
                                                        total_moment_y / total_weight * d_weight_dthickness) / total_weight

        partials['center_of_gravity_z', 'span'] = 0  # No camber means no variation
        partials['center_of_gravity_z', 'root_chord'] = 0
        partials['center_of_gravity_z', 'tip_chord'] = 0
        partials['center_of_gravity_z', 'thickness'] = 0

        # Compute derivatives of x_coords and z_coords w.r.t. twist
        twist = np.radians(inputs['twist'])
        for i in range(num_sections):
            partials['x_coords', 'twist'][i] = -centroid_xs[i] * np.sin(twist[i])
            partials['z_coords', 'twist'][i] = centroid_xs[i] * np.cos(twist[i])


def compute_partials(self, inputs, partials):
    """Compute the analytical derivatives of outputs with respect to inputs."""
    span = inputs['span']
    root_chord = inputs['root_chord']
    tip_chord = inputs['tip_chord']
    thickness = inputs['thickness']
    twist = np.radians(inputs['twist'])  # Convert twist from degrees to radians
    num_sections = self.options['num_sections']

    # Spanwise locations
    span_locations = np.linspace(0, span, num_sections)
    
    # Chord length variation (linear taper)
    chord_lengths = root_chord - (root_chord - tip_chord) * (span_locations / span)
    dchord_dspan = (tip_chord - root_chord) / span  # Chord gradient w.r.t. span

    # Compute centroid locations
    centroid_xs = chord_lengths / 4  # Approximate centroid X-location (quarter chord)
    centroid_ys = span_locations  # The spanwise locations
    centroid_zs = np.zeros_like(span_locations)  # Assume zero camber for now

    # Compute rotated centroid due to twist
    rotated_xs = centroid_xs * np.cos(twist) - centroid_zs * np.sin(twist)
    rotated_zs = centroid_xs * np.sin(twist) + centroid_zs * np.cos(twist)

    # Compute weight of each section
    section_areas = chord_lengths * thickness  # Simple approximation
    section_volumes = section_areas * (span / num_sections)  # Volume of each section
    section_weights = section_volumes  # Assuming uniform density

    # Compute total weight
    total_weight = np.sum(section_weights)

    # Compute moments for CoG
    total_moment_x = np.sum(rotated_xs * section_weights)
    total_moment_y = np.sum(centroid_ys * section_weights)
    total_moment_z = np.sum(rotated_zs * section_weights)

    # Compute derivatives of weight
    d_weight_dspan = np.sum(dchord_dspan * thickness * (span / num_sections)) + np.sum(chord_lengths * thickness / num_sections)
    d_weight_droot_chord = np.sum(thickness * (span / num_sections))
    d_weight_dtip_chord = np.sum(thickness * (span / num_sections) * (span_locations / span))
    d_weight_dthickness = np.sum(chord_lengths * (span / num_sections))

    # Compute derivatives of moments
    d_moment_x_dspan = np.sum((dchord_dspan / 4) * np.cos(twist) * section_weights)
    d_moment_y_dspan = np.sum(centroid_ys * (section_weights / span))  # dY/dspan is straightforward
    d_moment_z_dspan = np.sum((dchord_dspan / 4) * np.sin(twist) * section_weights)

    # Compute partials for CoG X
    partials['center_of_gravity_x', 'span'] = (d_moment_x_dspan - total_moment_x / total_weight * d_weight_dspan) / total_weight
    partials['center_of_gravity_x', 'root_chord'] = (np.sum(thickness * (span / num_sections) / 4) - total_moment_x / total_weight * d_weight_droot_chord) / total_weight
    partials['center_of_gravity_x', 'tip_chord'] = (np.sum(thickness * (span / num_sections) * (span_locations / span) / 4) - total_moment_x / total_weight * d_weight_dtip_chord) / total_weight
    partials['center_of_gravity_x', 'thickness'] = (np.sum(chord_lengths * (span / num_sections) / 4) - total_moment_x / total_weight * d_weight_dthickness) / total_weight

    # Compute partials for CoG Y
    partials['center_of_gravity_y', 'span'] = (d_moment_y_dspan - total_moment_y / total_weight * d_weight_dspan) / total_weight
    partials['center_of_gravity_y', 'root_chord'] = -total_moment_y / total_weight * d_weight_droot_chord / total_weight
    partials['center_of_gravity_y', 'tip_chord'] = -total_moment_y / total_weight * d_weight_dtip_chord / total_weight
    partials['center_of_gravity_y', 'thickness'] = -total_moment_y / total_weight * d_weight_dthickness / total_weight

    # Compute partials for CoG Z
    partials['center_of_gravity_z', 'span'] = (d_moment_z_dspan - total_moment_z / total_weight * d_weight_dspan) / total_weight
    partials['center_of_gravity_z', 'root_chord'] = (np.sum(thickness * (span / num_sections) / 4 * np.sin(twist)) - total_moment_z / total_weight * d_weight_droot_chord) / total_weight
    partials['center_of_gravity_z', 'tip_chord'] = (np.sum(thickness * (span / num_sections) * (span_locations / span) / 4 * np.sin(twist)) - total_moment_z / total_weight * d_weight_dtip_chord) / total_weight
    partials['center_of_gravity_z', 'thickness'] = (np.sum(chord_lengths * (span / num_sections) / 4 * np.sin(twist)) - total_moment_z / total_weight * d_weight_dthickness) / total_weight

    # Compute derivatives of x_coords and z_coords w.r.t. twist
    for i in range(num_sections):
        partials['x_coords', 'twist'][i] = -centroid_xs[i] * np.sin(twist[i])  # dx/dtwist
        partials['z_coords', 'twist'][i] = centroid_xs[i] * np.cos(twist[i])  # dz/dtwist

